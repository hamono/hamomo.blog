<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hamomo blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hamomo blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hamomo blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Hamomo">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hamomo blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hamomo blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-当前任务梳理（6.20）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/20/%E5%BD%93%E5%89%8D%E4%BB%BB%E5%8A%A1%E6%A2%B3%E7%90%86%EF%BC%886.20%EF%BC%89/" class="article-date">
  <time datetime="2020-06-20T08:57:45.403Z" itemprop="datePublished">2020-06-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/20/%E5%BD%93%E5%89%8D%E4%BB%BB%E5%8A%A1%E6%A2%B3%E7%90%86%EF%BC%886.20%EF%BC%89/">当前任务梳理（6.20）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="对当前任务进行梳理"><a href="#对当前任务进行梳理" class="headerlink" title="对当前任务进行梳理"></a>对当前任务进行梳理</h1><h2 id="前面遗留的问题"><a href="#前面遗留的问题" class="headerlink" title="前面遗留的问题"></a>前面遗留的问题</h2><ul>
<li>哈士奇文档</li>
<li>webpack</li>
<li>PWA缓存，新版本就绪提醒更新</li>
<li>文件全部ts化</li>
<li>依赖项优化</li>
<li>接入semantic-release自动生成changelog与发布流程等</li>
</ul>
<h2 id="接下来的任务"><a href="#接下来的任务" class="headerlink" title="接下来的任务"></a>接下来的任务</h2><ul>
<li>建设tf社区，tf-design</li>
<li>了解welab</li>
<li>bilibili继续优化页面</li>
<li>bilibili个页面添加业务逻辑</li>
<li>video-player完善控件与倍速</li>
<li>学习canvas</li>
<li>搭建一个简单的网站（你画我猜）</li>
<li>完成类SWR库</li>
<li>了解前端其他请求方式</li>
<li>学习ngnix</li>
<li>尝试添加多台服务器，利用ngnix进行负载均衡</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/20/%E5%BD%93%E5%89%8D%E4%BB%BB%E5%8A%A1%E6%A2%B3%E7%90%86%EF%BC%886.20%EF%BC%89/" data-id="ckbngd1wa000a14ugfgx175yr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-React的优势" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/21/React%E7%9A%84%E4%BC%98%E5%8A%BF/" class="article-date">
  <time datetime="2020-05-21T11:38:09.309Z" itemprop="datePublished">2020-05-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/21/React%E7%9A%84%E4%BC%98%E5%8A%BF/">React的优势</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="React-的优势与不足"><a href="#React-的优势与不足" class="headerlink" title="React  的优势与不足"></a>React  的优势与不足</h1><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><h3 id="virtual-dom虚拟DOM概念"><a href="#virtual-dom虚拟DOM概念" class="headerlink" title="virtual dom虚拟DOM概念"></a>virtual dom虚拟DOM概念</h3><p>react引入了虚拟DOM的概念，他并不直接对浏览器的DOM进行操作，这样做的优势在于减少了对于DOM的操作，提高了浏览器的渲染性能。</p>
<p>对于小型项目而言，表面上看不出react虚拟DOM的优势，但是对于复杂的大型项目优势就很明显。由此便出现了数据驱动UI。</p>
<h3 id="数据驱动UI的模式"><a href="#数据驱动UI的模式" class="headerlink" title="数据驱动UI的模式"></a>数据驱动UI的模式</h3><p>对于习惯了经典的操作浏览器DOM的前端人员来说，数据驱动UI可能是难以理解的，对于习惯了React编程的人员来说，渲染不同的UI界面只需要考虑给React传入不同的数据，这相对于最直接操作DOM来说可能是间接的，但是对于虚拟DOM来说，这个是非常必要的，但是事实上并不是所有的DOM操作都可以用虚拟DOM来解决，因此直接操作DOM是必不可少的。</p>
<h3 id="数据驱动与DOM操作并存的模式"><a href="#数据驱动与DOM操作并存的模式" class="headerlink" title="数据驱动与DOM操作并存的模式"></a>数据驱动与DOM操作并存的模式</h3><p>React在提出虚拟DOM后，针对操作数据无法解决的问题，依然支持直接的操作DOM，这对于React的使用者而言，如何减少直接操作DOM，是一个需要考虑的问题。</p>
<p>对于React而言，不同的数据是渲染不同UI的基础。</p>
<h3 id="自上而下的单向数据流"><a href="#自上而下的单向数据流" class="headerlink" title="自上而下的单向数据流"></a>自上而下的单向数据流</h3><p>React采用的是单项数据流模式，这样做的好处是所有的变化都是可预估、可控制的。不同于双向绑定的数据模式那样，变化一旦复杂起来，大家互相触发变化，到最后一个地方变了，你根本猜不出来她还会导致其他什么地方跟着一起变。因此，这种数据模式的优势显而易见。</p>
<p>但是，针对不同的、非祖先与后代关系的组件来说，可能有时候某些数据需要互通，React针对这种情况，提供了可跨组件传输数据的模式。</p>
<h3 id="跨组件的数据传输模式-createContext"><a href="#跨组件的数据传输模式-createContext" class="headerlink" title="跨组件的数据传输模式 createContext"></a>跨组件的数据传输模式 createContext</h3><p>对于需要数据互通的各个组件，React提供了相应的API，将需要互通的数据包裹其中，在其他的组件进行导入、应用，便能实现不同组件的数据互通。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/21/React%E7%9A%84%E4%BC%98%E5%8A%BF/" data-id="ckbngd1vx000114ug0por4gc6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-轮播图" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/04/%E8%BD%AE%E6%92%AD%E5%9B%BE/" class="article-date">
  <time datetime="2020-04-03T17:42:39.618Z" itemprop="datePublished">2020-04-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/04/%E8%BD%AE%E6%92%AD%E5%9B%BE/">轮播图</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>轮播图</title>
    <style>
      body {
        padding: 20px;
      }
      #container {
        position: relative;
        overflow: hidden;
        width: 600px;
        height: 400px;
      }
      #list {
        position: absolute;
        z-index: 1;
        width: 4200px;
        height: 400px;
      }
      #list div {
        float: left;
        width: 600px;
        height: 400px;
      }
      #buttons {
        position: absolute;
        z-index: 2;
        bottom: 20px;
        left: 250px;
        width: 100px;
        height: 10px;
      }
      #buttons span {
        float: left;
        width: 10px;
        height: 10px;
        margin-right: 5px;
        cursor: pointer;
        border: 1px solid #fff;
        border-radius: 50%;
        background: #333;
      }
      #buttons .on {
        background: orangered;
      }
      .arrow {
        font-size: 36px;
        font-weight: bold;
        line-height: 39px;
        position: absolute;
        z-index: 2;
        top: 180px;
        display: none;
        width: 40px;
        height: 40px;
        cursor: pointer;
        text-align: center;
        color: #fff;
        background-color: RGBA(0, 0, 0, 0.3);
      }
      .arrow:hover {
        background-color: RGBA(0, 0, 0, 0.7);
      }
      #container:hover .arrow {
        display: block;
      }
      #prev {
        left: 20px;
      }
      #next {
        right: 20px;
      }
      .item1 {
        background-color: aqua;
      }
      .item2 {
        background-color: rgb(228, 168, 113);
      }
      .item3 {
        background-color: rgb(140, 109, 212);
      }
      .item4 {
        background-color: rgb(147, 233, 166);
      }
      .item5 {
        background-color: rgb(234, 243, 243);
      }
      .item6 {
        background-color: rgb(187, 54, 116);
      }
      .item7 {
        background-color: rgb(228, 168, 113);
      }
    </style>
  <meta name="generator" content="Hexo 4.2.0"></head>
  <body>
    <h1>用HTML写的轮播图</h1>
    <div id="container">
      <div id="list" style="left:-600px;">
        <div class="item1"></div>
        <div class="item2"></div>
        <div class="item3"></div>
        <div class="item4"></div>
        <div class="item5"></div>
        <div class="item6"></div>
        <div class="item7"></div>
      </div>
      <div id="buttons">
        <span index="1" class="on"></span>
        <span index="2"></span>
        <span index="3"></span>
        <span index="4"></span>
        <span index="5"></span>
      </div>
      <a id="prev" class="arrow">&lt;</a>
      <a href="javascript:;" id="next" class="arrow">&gt;</a>
    </div>
    <script>
      window.onload = function() {
        var prev = document.getElementById("prev");
        var next = document.getElementById("next");
        var list = document.getElementById("list");
        var buttons = document
          .getElementById("buttons")
          .getElementsByTagName("span");
        var container = document.getElementById("container");
        var index = 1;
        var timer;
        var animated = false;
        function shownButton() {
          for (var i = 0; i < buttons.length; i++) {
            if (buttons[i].className == "on") {
              buttons[i].className = "";
              /* prev和next每click一次，
                        就会清除一次前一个class为on的span元素，
                        所以没有必要再去循环下面的span*/
              break;
            }
            //  或者直接遍历清除  buttons[i].className=""；
          }
          buttons[index - 1].className = "on";
        }
        function animate(offset) {
          var time = 300;
          var inteval = 10;
          var speed = offset / (time / inteval);
          animated = true; //更改全局变量，防止跳图
          var newLeft = parseInt(list.style.left) + offset;
          function go() {
            if (
              (speed > 0 && parseInt(list.style.left) < newLeft) ||
              (speed < 0 && parseInt(list.style.left) > newLeft)
            ) {
              list.style.left = parseInt(list.style.left) + speed + "px";
              setTimeout(go, inteval);
            } else {
              animated = false; //全局变量
              list.style.left = newLeft + "px";
              if (newLeft > -600) {
                list.style.left = -3000 + "px";
              }
              if (newLeft < -3000) {
                list.style.left = -600 + "px";
              }
            }
          }
          go();
        }
        prev.onclick = function() {
          /*添加一个if判断index为1时，如果继续往前滚的话就让index返回第五个span
                但是当快速点击arrow时会出现一种span点亮延迟的情况。可以尝试把判断index是否大于1或小于5的情况放进
                判断是否animated的if语句中，先判断能不能点击，再点亮。
                */
          if (!animated) {
            if (index == 1) {
              index = 5;
            } else {
              index -= 1;
            }
            shownButton();
            animate(600);
          }
        };
        next.onclick = function() {
          if (!animated) {
            if (index == 5) {
              index = 1;
            } else {
              index += 1;
            }
            shownButton();
            animate(-600);
          }
        };
        for (var i = 0; i < buttons.length; i++) {
          buttons[i].onclick = function() {
            //无关紧要
            if (this.className == "on") {
              return;
            }
            var myIndex = parseInt(this.getAttribute("index"));
            var offset = -600 * (myIndex - index);
            if (!animated) {
              animate(offset);
            }
            index = myIndex;
            shownButton();
          };
        }
        function play() {
          timer = setInterval(function() {
            next.onclick();
          }, 2000);
        }
        function stop() {
          clearInterval(timer);
        }
        play();
        container.onmouseover = stop;
        container.onmouseout = play;
      };
    </script>
  </body>
</html>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/04/%E8%BD%AE%E6%92%AD%E5%9B%BE/" data-id="ckbngd1wc000d14ugbmzx982w" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-da" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/02/da/" class="article-date">
  <time datetime="2020-04-02T10:54:53.561Z" itemprop="datePublished">2020-04-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/02/da/">da</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  <meta name="generator" content="Hexo 4.2.0"></head>
  <body>
    大数一：<input class="num1" /> 大数二：<input class="num2" />
    <p>请输入两个大数测试</p>
    <button class="but" onClick="add()">确定</button>
    <script>
      function sumString(a, b) {
        //取两个数字的最大长度
        let maxLength = Math.max(a.length, b.length);
        //用0去补齐长度
        a = a.padStart(maxLength, 0); //"0009007199254740991"
        b = b.padStart(maxLength, 0); //"1234567899999999999"
        //定义加法过程中需要用到的变量
        let t = 0;
        let f = 0; //"进位"
        let sum = "";
        for (let i = maxLength - 1; i >= 0; i--) {
          t = parseInt(a[i]) + parseInt(b[i]) + f;
          f = Math.floor(t / 10);
          sum = (t % 10) + sum;
        }
        if (f == 1) {
          sum = "1" + sum;
        }
        return sum;
      }
      function add() {
        var num1 =document.querySelector(".num1");
        console.log(typeof(num1))
        console.log(num1.value)
        var num2 = document.querySelector(".num2");
        console.log(typeof(num2))
        var but = document.querySelector("p");
        but.textContent = sumString(num1.value, num2.value);

      }
    </script>
  </body>
</html>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/02/da/" data-id="ckbngd1w4000314ug8rbv41sb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-大数相加" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/02/%E5%A4%A7%E6%95%B0%E7%9B%B8%E5%8A%A0/" class="article-date">
  <time datetime="2020-04-02T10:28:41.032Z" itemprop="datePublished">2020-04-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/02/%E5%A4%A7%E6%95%B0%E7%9B%B8%E5%8A%A0/">大数相加</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="javascript-实现两个大数的相加"><a href="#javascript-实现两个大数的相加" class="headerlink" title="javascript 实现两个大数的相加"></a>javascript 实现两个大数的相加</h1><h2 id="大数超出了-Javascript-的数值范围，用字符串表示"><a href="#大数超出了-Javascript-的数值范围，用字符串表示" class="headerlink" title="大数超出了 Javascript 的数值范围，用字符串表示"></a>大数超出了 Javascript 的数值范围，用字符串表示</h2><pre><code>function sumString(a, b) {
  //取两个数字的最大长度
  let maxLength = Math.max(a.length, b.length);
  //用0去补齐长度
  a = a.padStart(maxLength, 0); //&quot;0009007199254740991&quot;
  b = b.padStart(maxLength, 0); //&quot;1234567899999999999&quot;
  //定义加法过程中需要用到的变量
  let t = 0;
  let f = 0; //&quot;进位&quot;
  let sum = &quot;&quot;;
  for (let i = maxLength - 1; i &gt;= 0; i--) {
    t = parseInt(a[i]) + parseInt(b[i]) + f;
    f = Math.floor(t / 10);
    sum = (t % 10) + sum;
  }
  if (f == 1) {
    sum = &quot;1&quot; + sum;
  }
  return sum;
}</code></pre><p>大数一：<input class='num1' /></br></p>
<p>大数二：<input class='num2'/></p>
<p class='p'>请输入两个大数测试</p>

<p><button class='but' onClick='add()'>确定</button></p>
<script>
function sumString(a, b) {
//取两个数字的最大长度
let maxLength = Math.max(a.length, b.length);
//用 0 去补齐长度
a = a.padStart(maxLength, 0); //"0009007199254740991"
b = b.padStart(maxLength, 0); //"1234567899999999999"
//定义加法过程中需要用到的变量
let t = 0;
let f = 0; //"进位"
let sum = "";
for (let i = maxLength - 1; i >= 0; i--) {
t = parseInt(a[i]) + parseInt(b[i]) + f;
f = Math.floor(t / 10);
sum = (t % 10) + sum;
}
if (f == 1) {
sum = "1" + sum;
}
return sum;
}
function add() {
var num1 =document.querySelector(".num1");
var num2 = document.querySelector(".num2");
var but = document.querySelector(".p");
but.textContent = sumString(num1.value, num2.value);

      }

</script>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/02/%E5%A4%A7%E6%95%B0%E7%9B%B8%E5%8A%A0/" data-id="ckbngd1we000e14ug55buhulu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-this是指向哪的" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/28/this%E6%98%AF%E6%8C%87%E5%90%91%E5%93%AA%E7%9A%84/" class="article-date">
  <time datetime="2020-03-28T08:44:15.825Z" itemprop="datePublished">2020-03-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/28/this%E6%98%AF%E6%8C%87%E5%90%91%E5%93%AA%E7%9A%84/">this是指向哪的</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h1><p>总的来说，指向离他最近的function关键字所属的对象。</p>
<p>一般绑定this的方法有以下几种：</p>
<ol>
<li>箭头函数</li>
<li>关键字new</li>
<li>显式绑定</li>
<li>隐式绑定</li>
<li>默认绑定</li>
</ol>
<p>以上按照优先级从高到低排列。</p>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><pre><code>function Person(){
  this.age = 0;
  setTimeout(function () {
    console.log(this.age);     // 输出undefined
  }, 1000);
}
var p = new Person();

function Person(){
  this.age = 10;
  setTimeout(()=&gt; {
    console.log(this.age);     // 输出10
  }, 1000);
}
var p = new Person();</code></pre><p>在上述的箭头函数的例子中，setTimeout内部的函数是被global调用的，而global没有阿哥这个属性，输出undefined。</p>
<p>第二个使用箭头函数，this会绑定在Person上；因为箭头函数不会绑定this，导致setTimeout函数内部的函数不会绑定到global上。</p>
<h2 id="new关键字"><a href="#new关键字" class="headerlink" title="new关键字"></a>new关键字</h2><pre><code>function foo() { 
    this.baz = &quot;baz&quot;; 
    console.log(this.bar + &quot; &quot; + baz); 
} 
    var baz = new foo();
var bar = &quot;bar&quot;; 
var baz = new foo(); </code></pre><p>new关键字在函数的调用前，会创建一个新的对象实例，这个函数为实例的构造函数。</p>
<p>按照前文提到的this绑定的方法，在这个例子中，离this最近的function是foo，此时foo属于baz，所以this指向的是baz对象，在baz上并没有bar，global上没有baz，所以输出undefined undefined。</p>
<h2 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h2><pre><code>function foo() { 
console.log(this.bar); 
} 
var bar = &quot;bar1&quot;; 
var obj = {bar: &quot;bar2&quot;}; 

foo();
foo.call(obj);</code></pre><p>通过call显示绑定this</p>
<h2 id="默认绑定和隐式绑定"><a href="#默认绑定和隐式绑定" class="headerlink" title="默认绑定和隐式绑定"></a>默认绑定和隐式绑定</h2><pre><code>function foo() { 
    console.log(this.bar); 
} 
var bar = &quot;bar1&quot;; 
var o2 = {bar: &quot;bar2&quot;, foo: foo}; 
var o3 = {bar: &quot;bar3&quot;, foo: foo}; 
foo();            // &quot;bar1&quot; – 默认绑定
o2.foo();          // &quot;bar2&quot; – 隐式绑定
o3.foo();          // &quot;bar3&quot; – 隐式绑定</code></pre><p>调用函数foo，foo的function所属的对象是window，所以foo的this.bar指window的bar。</p>
<p>在o2和o3中，foo的function所属的对象分别是o2和o3，所以，this.bar分别指bar2和bar3。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，this的指向除非通过一些方法显示规定，否则都是指向离他最近的function关键字所属的对象。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/28/this%E6%98%AF%E6%8C%87%E5%90%91%E5%93%AA%E7%9A%84/" data-id="ckbngd1wa000914ug2674036k" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-从输入URL到页面加载发生了什么" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/27/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/" class="article-date">
  <time datetime="2020-03-27T12:59:15.473Z" itemprop="datePublished">2020-03-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/27/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/">从输入URL到页面加载发生了什么</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="从输入-URL-到页面加载发生了什么"><a href="#从输入-URL-到页面加载发生了什么" class="headerlink" title="从输入 URL 到页面加载发生了什么"></a>从输入 URL 到页面加载发生了什么</h1><h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>首先，在回答在个问题之前，我们需要搞清楚<code>URL</code>是什么。</p>
<p>常见的 URL 会包含：</p>
<ul>
<li>协议名<br>常见的协议是 HTTP 协议，除此之外还包括<ul>
<li>HTTPS</li>
<li>FTP</li>
<li>FILE 等</li>
</ul>
</li>
<li>域名</li>
<li>端口号<br>端口号一般都是默认隐藏的，HTTP 协议默认端口是 80，HTTPS 协议默认端口是 443.</li>
<li>path<br>一般取决于服务器的路由结构</li>
<li>问号参数和 hash<ul>
<li>问号传参是客户端把信息传递给服务器的一种方式(也有可能是跳转到某一个页面，把参数值传递给页面用来标识的)</li>
<li>hash 主要用于页面中锚点定位和 hash 路由切换</li>
</ul>
</li>
</ul>
<h2 id="从输入-URL-到页面加载发生的事"><a href="#从输入-URL-到页面加载发生的事" class="headerlink" title="从输入 URL 到页面加载发生的事"></a>从输入 URL 到页面加载发生的事</h2><p>这个过程主要可以分为以下几个过程：</p>
<ul>
<li>DNS 解析</li>
<li>建立 TCP 连接</li>
<li>客户端发送 HTTP 协议</li>
<li>服务器返回 response</li>
<li>浏览器渲染页面</li>
<li>结束连接</li>
</ul>
<h3 id="DNS-解析"><a href="#DNS-解析" class="headerlink" title="DNS 解析"></a>DNS 解析</h3><p>DNS 解析是找到对应服务器的 IP 地址</p>
<ul>
<li>查找方法有：迭代和递归两种</li>
<li>查询的位置有<ul>
<li>浏览器缓存</li>
<li>操作系统缓存</li>
<li>本地域名服务器</li>
<li>顶级域名服务器</li>
<li>根域名服务器<br>直到获得准确的 IP 地址</li>
</ul>
</li>
</ul>
<h3 id="建立-TCP-连接"><a href="#建立-TCP-连接" class="headerlink" title="建立 TCP 连接"></a>建立 TCP 连接</h3><p>在获得 IP 地址后，便开始建立一次连接，由 TCP 协议完成，主要通过 3 次握手进行连接，作为前端工程师，这与我们的前端关系不大，就不细说。</p>
<h3 id="客户端发送-HTTP-请求"><a href="#客户端发送-HTTP-请求" class="headerlink" title="客户端发送 HTTP 请求"></a>客户端发送 HTTP 请求</h3><p>这里的客户端主要指浏览器，还有其他的，比如命令行和一些前端调试工具等。</p>
<h4 id="HTTP-与-HTTPS-的区别"><a href="#HTTP-与-HTTPS-的区别" class="headerlink" title="HTTP 与 HTTPS 的区别"></a>HTTP 与 HTTPS 的区别</h4><p>HTTP 报文是包裹在 TCP 报文中发送的，HTTP 报文是明文，容易被截取，所以就出现了 HTTPS。HTTPS 在讲 HTTP 报文包裹进 TCP 报文时，使用 SSL 进行了加密，HTTPS 在数据传输之前，客户端会与服务器进行一次握手，确定加密传输的密码信息，如此可以保证数据传输的安全性。</p>
<h4 id="HTTP-请求"><a href="#HTTP-请求" class="headerlink" title="HTTP 请求"></a>HTTP 请求</h4><p>包含三部分：请求行、请求报头和请求正文。</p>
<ul>
<li>请求行</li>
</ul>
<ol>
<li><p>一个 HTTP 方法：<code>GET</code> <code>PUT</code> <code>POST</code> <code>OPTION</code> <code>HEAD</code>等；</p>
</li>
<li><p>请求目标：通常是一个 URL，或者是协议、端口和域名的绝对路径；</p>
</li>
<li><p>HTTP 版本</p>
</li>
</ol>
<ul>
<li>header部分</li>
</ul>
<p>允许客户端向服务器传递请求的附加信息和客户端自身的信息，常见的请求报头有：</p>
<ol>
<li>Accept：指定客户端用于接受哪些类型的信息</li>
<li>Accept-Encoding：用于指定接受的编码方式</li>
<li>Connection：设置为Keep-alive用于告诉客户端本次HTTP请求结束之后并不需要关闭TCP连接，这样可以使下次HTTP请求使用相同的TCP通道，节省TCP连接建立的时间</li>
<li>Accept-Language：指定接受的语言</li>
<li>Cache-Control：缓存控制</li>
</ol>
<ul>
<li>请求正文</li>
</ul>
<p>当使用POST, PUT等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中。</p>
<h3 id="服务器返回-response"><a href="#服务器返回-response" class="headerlink" title="服务器返回 response"></a>服务器返回 response</h3><p>响应消息也是由三部分构成：状态行、响应消息报头以及响应正文</p>
<ul>
<li>状态行</li>
</ul>
<p>由HTTP协议版本号，状态码和原因描述组成</p>
<ol>
<li>状态码：常见的有200,304,404,500等</li>
</ol>
<ul>
<li>响应消息报头</li>
</ul>
<p>常见的报头有：</p>
<ol>
<li>Location：用于重定向接受者到一个新的位置</li>
<li>Server：包含了服务器用来处理请求的软件信息</li>
<li>Content-Length：用于指明实体正文的长度</li>
<li>Content-Type：用于指明发送给接收者的实体正文的媒体类型</li>
<li>其他等</li>
</ol>
<ul>
<li>响应正文</li>
</ul>
<p>一般是服务器发给客户端的内容，包括HTML、图片等</p>
<h3 id="浏览器渲染界面"><a href="#浏览器渲染界面" class="headerlink" title="浏览器渲染界面"></a>浏览器渲染界面</h3><p>如果说响应的内容是HTML文档的话，就需要浏览器进行解析渲染呈现给用户。整个过程涉及两个方面：解析和渲染；对于现代浏览器，为了达到更好的用户体验，浏览器的呈现引擎会力求尽快将内容显示到屏幕上；而不必等到整个HTML文档解析完毕之后再去构建渲染树然后布局渲染；也就是说这是一个渐进的过程。</p>
<h4 id="解析，构建对象模型"><a href="#解析，构建对象模型" class="headerlink" title="解析，构建对象模型"></a>解析，构建对象模型</h4><p>在渲染页面之前，需要构建DOM树和CSSOM树。</p>
<p>DOM树和CSSOM树的构建基本过程是这样的：</p>
<ol>
<li>Conversion转换：浏览器将获得的HTML内容（Bytes）基于他的编码转换为单个字符</li>
<li>Tokenizing分词：浏览器按照HTML规范标准将这些字符转换为不同的标记token。每个token都有自己独特的含义以及规则集</li>
<li>Lexing词法分析：分词的结果是得到一堆的token，此时把他们转换为对象，这些对象分别定义他们的属性和规则</li>
<li>DOM构建：因为HTML标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构一样</li>
</ol>
<h4 id="构建渲染树"><a href="#构建渲染树" class="headerlink" title="构建渲染树"></a>构建渲染树</h4><p>渲染树与DOM树对应，但并不是一一对应，因为非可视化的DOM元素不会被插入到渲染树中，例如head元素、display：none不会出现在渲染树。</p>
<h4 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h4><p>有了渲染树，就可以进行渲染了，包含四个步骤：</p>
<ol>
<li>计算CSS样式</li>
<li>构建渲染树</li>
<li>布局，主要定位坐标和大小，是否换行，各种position、overflow、z-index等</li>
<li>调用操作系统Native GUI的api绘制内容</li>
</ol>
<p>JS动态修改了DOM或者CSSOM，会导致重新布局或者渲染</p>
<p>这里涉及到了两个重要的概念：reflow（回流）和repaint（重绘）</p>
<ul>
<li>reflow：一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树，这个过程称为Reflow</li>
<li>repaint：意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就OK了，这个过程称为Repaint</li>
</ul>
<p>所以说Reflow的成本比Repaint的成本高得多的多。DOM树里的每个结点都会有reflow方法，一个结点的reflow很有可能导致子结点，甚至父点以及同级结点的reflow</p>
<p>下面这些动作很大可能会是成本比较高的：</p>
<ul>
<li>增加、删除、修改DOM结点时，会导致Reflow或Repaint</li>
<li>移动DOM的位置，或是搞个动画的时候</li>
<li>内容发生变化</li>
<li>修改CSS样式的时候</li>
<li>Resize窗口的时候（移动端没有这个问题），或是滚动的时候</li>
<li>修改网页的默认字体时</li>
</ul>
<p>注：display:none会触发reflow，而visibility:hidden只会触发repaint，因为没有发生位置变化。</p>
<p>基本上来说，reflow有如下的几个原因：</p>
<ul>
<li>网页初始化的时候</li>
<li>一些Javascript在操作DOM树时</li>
<li>其些元件的尺寸变了</li>
<li>如果CSS的属性发生变化了</li>
<li>几个Incremental的reflow发生在同一个frame的子树上</li>
</ul>
<h4 id="解析和渲染总结"><a href="#解析和渲染总结" class="headerlink" title="解析和渲染总结"></a>解析和渲染总结</h4><p>这里需要注意的一件事情就是在HTML解析过程中回去加载外链的CSS，但是不会影响继续解析HTML的；在外链CSS得到之后要解析CSS。从前面的介绍可知渲染的话是需要DOM和CSSOM一起构建出来渲染树，然后渲染出来的，也就是说默认情况下CSS是会阻塞渲染的，为啥说默认情况呢，难道还有不阻塞渲染的时候？答案是有的，通过media query就可以使得CSS资源是非阻塞渲染的。</p>
<h4 id="JS脚本"><a href="#JS脚本" class="headerlink" title="JS脚本"></a>JS脚本</h4><p>说完了DOM和CSSOM了，就该说说这个JS脚本了</p>
<p>通过JS脚本可以通过DOM API和CSSOM API来才做DOM树和CSSOM树（或者说CSS规则树）；但是呢JS是会阻塞DOM的构建（除非显示的声明为异步async的）也会阻塞CSSOM的构建，也就意味着会推迟这个页面的渲染完成。</p>
<p>在页面中的脚本有两种情况，一种就是内嵌的，还有一种外链的</p>
<p>对于脚本内嵌的情况，在解析HTML的过程中，直接执行脚本，这个时候会阻塞HTML解析来构建DOM，因为CSS不会修改DOM；还有一种情况那就是如果说正在脚本前面还有CSS的话，而此时CSSOM还未构建完成，那么浏览器就会推迟脚本的执行直至下载并构建好了CSSOM，而且在这个等待的过程中DOM的构建也会停止。所以说，在内嵌脚本之前不要有外链CSS，否则的话就会出现所谓的“CSS阻塞”，其实就是必须等到CSS加载完成解析构建CSSOM之后才会执行脚本，执行完脚本才会继续解析HTML构建DOM（这里Webkit则更智能一点，在执行脚本过程中发现引用了样式的话才暂停脚本的执行，等待CSS下载解析，然后再恢复）</p>
<p>然后第二种情况，对于外链脚本而言，在解析HTML的过程中发现了外链的脚本，会发一个请求去得到脚本内容，但是这个过程是同步的，需要等待脚本下载完成且执行之后才会继续解析HTML构建DOM；但是对于现代浏览器在这个时候会生成第二个线程解析HTML文档，会继续下载资源，所以有多个外链脚本的话，会并行请求下载脚本内容，但是浏览器对于一个域的资源是有最大并行限制的，一般是6个，超过的就只能等待了。脚本虽然可以并行加载，但是执行的顺序是按照在页面中先后顺序执行的，执行的过程会阻塞后续解析构建渲染，同样也会阻止其他资源的下载。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此，输入一个简单的URL到页面加载的简单过程就完毕了，在这个过程中，对于前端工程师而言，需要很熟悉页面的渲染过程，以消耗最少的成本完成页面的加载，代码的优化是无止境的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/27/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/" data-id="ckbngd1wo000f14ughk434s1v" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-webpack中的loader和plugin" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/15/webpack%E4%B8%AD%E7%9A%84loader%E5%92%8Cplugin/" class="article-date">
  <time datetime="2020-03-15T00:40:33.485Z" itemprop="datePublished">2020-03-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/15/webpack%E4%B8%AD%E7%9A%84loader%E5%92%8Cplugin/">webpack中的loader和plugin</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h1><p>webpack 默认只识别 js 结尾的文件，当遇到其他格式后，webpack 并不知道如何去处理。此时，我们需要定义一种规则，告诉 webpack，当遇到其他类型的问件时，去求助于相应的 loader。</p>
<ul>
<li>识别出应该被对应的 loader 进行转换的文件。（test 属性）</li>
<li>转换这些文件，使其能够被添加到依赖图中。（use 属性）</li>
</ul>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><ul>
<li>test：匹配处理文件的拓展名的表达式，必须</li>
<li>user：使用的 loader 模块名称，必须</li>
<li>include/exclude：手动添加必须处理的文件（夹）或屏蔽不需要处理的文件，可选</li>
<li>query：为 loader 提供额外的设置选项，可选</li>
</ul>
<h1 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h1><p>loader 被用于转换某些类型的模块，而插件则可以用于执行广泛的任务。想要使用一个插件，你只需要 require()它，然后将它添加到 plugins 数组中。多数插件可以通过选项自定义。你也可以在一个配置中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建它的一个实例。</p>
<h2 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h2><pre><code>plugins:[执行的插件]</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/15/webpack%E4%B8%AD%E7%9A%84loader%E5%92%8Cplugin/" data-id="ckbngd1wc000c14ug7k2yf8s1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-task" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/05/task/" class="article-date">
  <time datetime="2020-03-05T09:48:01.382Z" itemprop="datePublished">2020-03-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/05/task/">task</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Document</title>
  <style>
    .box{
      width: 1440px;
      margin: 0 auto;
      height: 5000px;
      background-color: aqua;
    }
  </style>
<meta name="generator" content="Hexo 4.2.0"></head>
<body>
  <div class="box">
    start
  </div>
  <div class="main">
    <div class="item"></div>
    <div class="item"></div>
    <div class="item"></div>
    <div class="item"></div>
    <div class="item"></div>
    <div class="item"></div>
  </div>
</body>
</html>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/05/task/" data-id="ckbngd1w7000714uga5k3ewnu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-text" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/05/text/" class="article-date">
  <time datetime="2020-03-05T07:42:34.827Z" itemprop="datePublished">2020-03-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/05/text/">text</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Document</title>
<meta name="generator" content="Hexo 4.2.0"></head>
<body>
  <p>请输入半径</p>
  <input type="text" onchange="input()">
  <button>确认</button>
</body>
<script>
  function input(){
    const inputs=document.querySelector('input');
    const p=document.querySelector('p');
    p.textContent=inputs.value*inputs.value*3.14;
  }
</script>
</html>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/05/text/" data-id="ckbngd1wb000b14ugbwtue43d" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/20/%E5%BD%93%E5%89%8D%E4%BB%BB%E5%8A%A1%E6%A2%B3%E7%90%86%EF%BC%886.20%EF%BC%89/">当前任务梳理（6.20）</a>
          </li>
        
          <li>
            <a href="/2020/05/21/React%E7%9A%84%E4%BC%98%E5%8A%BF/">React的优势</a>
          </li>
        
          <li>
            <a href="/2020/04/04/%E8%BD%AE%E6%92%AD%E5%9B%BE/">轮播图</a>
          </li>
        
          <li>
            <a href="/2020/04/02/da/">da</a>
          </li>
        
          <li>
            <a href="/2020/04/02/%E5%A4%A7%E6%95%B0%E7%9B%B8%E5%8A%A0/">大数相加</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Hamomo<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>