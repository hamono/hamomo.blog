<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hamomo blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hamomo blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hamomo blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Hamomo">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hamomo blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hamomo blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-React异步" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/03/React%E5%BC%82%E6%AD%A5/" class="article-date">
  <time datetime="2020-03-02T16:45:30.081Z" itemprop="datePublished">2020-03-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/03/React%E5%BC%82%E6%AD%A5/">React异步</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="setState的异步调用"><a href="#setState的异步调用" class="headerlink" title="setState的异步调用"></a>setState的异步调用</h1><p><code>setState</code>是异步的，在class式的组件中，<code>this.state</code>表示当前渲染的值，在hook中<code>state</code>是同样的效果。</p>
<p>所以<code>this.setState</code>或者<code>setState</code>到底什么时候才会重新渲染呢？</p>
<p><code>setState</code> 函数用于更新 <code>state</code>。它接收一个新的 <code>state</code> 值并将组件的一次重新渲染加入队列。在后续的重新渲染中，useState 返回的第一个值将始终是更新后最新的 <code>state</code>。（这段话来自hook文档）</p>
<p>那么，“加入队列”怎么理解，“后续的重新渲染”又是什么时候呢？</p>
<p>先看一段代码：</p>
<pre><code>const [count, setCount] = React.useState(0);
return &lt;div&gt;
  &lt;p&gt;You clicked {count} times&lt;/p&gt;
  &lt;button onClick={() =&gt; setCount(count + 1)}&gt;click&lt;/button&gt;
  &lt;/div&gt;</code></pre><p>显而易见，打印的<code>count</code>的每次click都会加1，那么问题又来了，具体完成重新渲染是哪呢：是<code>onclick</code>函数执行完重新渲染呢，还是<code>setCount</code>执行完重新渲染呢？</p>
<p>观察下面的代码</p>
<pre><code>const [count, setCount] = React.useState(0);
function handleValue(){
  setCount(count+1)
  setCount(count+1)
}
return &lt;div&gt;
  &lt;p&gt;You clicked {count} times&lt;/p&gt;
  &lt;button onClick={handleValue}&gt;click&lt;/button&gt;
&lt;/div&gt;</code></pre><p>让我们猜一猜点击按钮一次，<code>count</code>的值是多少呢？</p>
<p>是1呢还是2呢？当然是1，所以setState并不会立刻rerender，正如上文所说，加入到了一个等待rerender的队列，按照上面的测试结果，我们是不是可以这样说：同一个函数内部的相同的setState只会执行一次，而它重新渲染是在其所在函数结束时。</p>
<p>真相真的是这样吗？</p>
<pre><code>const [count, setCount] = React.useState(0);
  function handleValue(){
    setCount((state)=&gt;state+1)
    setCount((state)=&gt;state+1)
  }
  return &lt;div&gt;
    &lt;p&gt;You clicked {count} times&lt;/p&gt;
    &lt;button onClick={handleValue}&gt;click&lt;/button&gt;
  &lt;/div&gt;</code></pre><p>那么这个点击一次的结果又是什么呢？</p>
<p>很明显这次不是1了，<code>count</code>是2了，这又是为什么呢？</p>
<p>首先要搞清参数<code>state</code>是什么</p>
<p>官方说法：<code>state</code> 是对应用变化时组件状态的引用。</p>
<p>通俗的说就是当前的<code>state</code>的值(<code>this.state</code>),也就是代码示例中的count值，因为count是不允许随意修改的，只能通过与其匹配的setCount传递值，所以这里使用了参数，所以这是一个很实惠(代码数量增加不多，解决的问题很关键)的消除异步的方法。(其实官方这样设计这个方法的时候目的是为了性能着想)</p>
<p>但是，关键的setState并不是总是异步的，只有在事件处理函数内部是才是异步的。</p>
<p>下面还有一段有趣的代码：</p>
<pre><code>const list=[1,1,1,1,1,1];
const [count, setCount] = React.useState([]);
function handleValue(){
  list.map((v:number)=&gt;{
    setCount([...count,v])
  })
}
return &lt;div&gt;
  &lt;p&gt; {count} &lt;/p&gt;
  &lt;button onClick={handleValue}&gt;click&lt;/button&gt;
&lt;/div&gt;</code></pre><p>setState的队列属性使得这种方法无法实现应有的效果，所以，我们修改：</p>
<pre><code>const list=[1,1,1,1,1,1];
const [count, setCount] = React.useState([]);
function handleValue(){
  list.map((v:number)=&gt;{
    setCount((state)=&gt;[...state,v])
  })
}
return &lt;div&gt;
  &lt;p&gt; {count} &lt;/p&gt;
  &lt;button onClick={handleValue}&gt;click&lt;/button&gt;
&lt;/div&gt;</code></pre><p>如此，这个问题便解决了</p>
<p>这个是之前项目中出现的问题，解决了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/03/React%E5%BC%82%E6%AD%A5/" data-id="ckbng8xmx0001dgugb4xzgmgb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-fetch相关api及异步" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/02/fetch%E7%9B%B8%E5%85%B3api%E5%8F%8A%E5%BC%82%E6%AD%A5/" class="article-date">
  <time datetime="2020-03-01T16:52:28.312Z" itemprop="datePublished">2020-03-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/02/fetch%E7%9B%B8%E5%85%B3api%E5%8F%8A%E5%BC%82%E6%AD%A5/">fetch相关api及异步</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="fetch-相关-API"><a href="#fetch-相关-API" class="headerlink" title="fetch 相关 API"></a>fetch 相关 API</h1><h2 id="fetch"><a href="#fetch" class="headerlink" title="fetch()"></a>fetch()</h2><p>fetch 请求</p>
<pre><code>fetch(&apos;http://example.com/movies.json&apos;)
.then(function(response) {
  return response.json();
})
.then(function(myJson) {
  console.log(myJson);
});</code></pre><p>他可以接受两个参数，可以为一个请求的基本信息，如下：</p>
<pre><code>function postData(url, data) {
  return fetch(url, {
    body: JSON.stringify(data), // must match &apos;Content-Type&apos; header
    cache: &apos;no-cache&apos;, // *default, no-cache, reload, force-cache, only-if-cached
    credentials: &apos;same-origin&apos;, // include, same-origin, *omit
    headers: {
      &apos;user-agent&apos;: &apos;Mozilla/4.0 MDN Example&apos;,
      &apos;content-type&apos;: &apos;application/json&apos;
    },
    method: &apos;POST&apos;, // *GET, POST, PUT, DELETE, etc.
    mode: &apos;cors&apos;, // no-cors, cors, *same-origin
    redirect: &apos;follow&apos;, // manual, *follow, error
    referrer: &apos;no-referrer&apos;, // *client, no-referrer
  })
  .then(response =&gt; response.json()) // parses response to JSON
}</code></pre><h2 id="上传-json-数据实例"><a href="#上传-json-数据实例" class="headerlink" title="上传 json 数据实例"></a>上传 json 数据实例</h2><pre><code>let url = &apos;https://example.com/profile&apos;;
let data = {username: &apos;example&apos;};

fetch(url, {
  method: &apos;POST&apos;, // or &apos;PUT&apos;
  body: JSON.stringify(data), // data can be `string` or {object}!
  headers: new Headers({
    &apos;Content-Type&apos;: &apos;application/json&apos;
  })
}).then(res =&gt; res.json())
.catch(error =&gt; console.error(&apos;Error:&apos;, error))
.then(response =&gt; console.log(&apos;Success:&apos;, response));</code></pre><h2 id="await"><a href="#await" class="headerlink" title="await"></a>await</h2><p>等待一个<code>promise</code>对象，只能在异步函数中使用。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre><code>[return_value] = await expression;</code></pre><p>expression：一个 Promise 对象或者任何要等待的值。<br>return_value：返回 Promise 对象的处理结果。如果等待的不是 Promise 对象，则返回该值本身。</p>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>await 表达式会暂停当前异步函数的执行，等待 Promise 处理完成。若 Promise 正常处理(fulfilled)，其回调的resolve函数参数作为 await 表达式的值，继续执行异步函数。</p>
<p>若 Promise 处理异常(rejected)，await 表达式会把 Promise 的异常原因抛出。</p>
<h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><p>看段代码：<br>    function read() {<br>      console.log(‘小明认真读书’);<br>    }</p>
<pre><code>function eat() {
  return new Promise((resolve, reject) =&gt; {
    console.log(&apos;好嘞，吃饭咯&apos;);
    setTimeout(() =&gt; {
      resolve(&apos;饭吃饱啦&apos;);
    }, 1000)
  })
}

const cooking = new Promise((resolve, reject) =&gt; {
  console.log(&apos;妈妈认真做饭&apos;);
  setTimeout(() =&gt; {
    resolve(&apos;小明快过来，开饭啦&apos;);
  }, 3000);
})

cooking.then(msg =&gt; {
  console.log(msg);
  return eat();
})
read();</code></pre><p>执行顺序：</p>
<p>妈妈认真做饭</p>
<p>小明认真读书</p>
<p>小明快过来，开饭了</p>
<p>好嘞，吃饭了</p>
<p>饭吃饱啦</p>
<p>promise的优点：将执行代码与处理数据的代码清晰的分离，在执行若干个异步函数时，将非常有用</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/02/fetch%E7%9B%B8%E5%85%B3api%E5%8F%8A%E5%BC%82%E6%AD%A5/" data-id="ckbng8xnc0004dgug17il1jpg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-http常见header" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/01/http%E5%B8%B8%E8%A7%81header/" class="article-date">
  <time datetime="2020-03-01T07:35:09.863Z" itemprop="datePublished">2020-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/01/http%E5%B8%B8%E8%A7%81header/">http常见header</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="http-常见的-header"><a href="#http-常见的-header" class="headerlink" title="http 常见的 header"></a>http 常见的 header</h1><h2 id="get-和-post-的区别"><a href="#get-和-post-的区别" class="headerlink" title="get 和 post 的区别"></a>get 和 post 的区别</h2><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><ul>
<li><code>GET</code> 方法请求指定的资源。使用 GET 的请求应该只用于获取数据。</li>
</ul>
<h3 id="post"><a href="#post" class="headerlink" title="post"></a>post</h3><ul>
<li><code>POST</code> 方法发送数据给服务器. 请求主体的类型由 Content-Type 首部指定.<ul>
<li>一个 <code>POST</code> 请求通常是通过 HTML 表单发送, 并返回服务器的修改结果. 在这种情况下, content type 是通过在 <code>&lt;form&gt;</code> 元素中设置正确的 enctype 属性, 或是在 <code>&lt;input&gt;</code> 和 <code>&lt;button&gt;</code> 元素中设置 formenctype 属性来选择的;</li>
<li>当 POST 请求是通过除 HTML 表单之外的方式发送时, 例如使用 XMLHttpRequest, 那么请求主体可以是任何类型;</li>
</ul>
</li>
</ul>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li><code>get</code>只能获取数据，<code>post</code>可以发送数据，并返回服务器的修改结果</li>
</ul>
<h2 id="http2"><a href="#http2" class="headerlink" title="http2"></a>http2</h2><p>随着 web 应用的发展，更多的数据通过 HTTP 传输，HTTP/1.1 链接需要请求以正确的顺序发送，，带来的成本和复杂性堪忧。HTTP/2 应运而生。</p>
<p>HTTP/2 在 HTTP/1.1 有几处基本的不同:</p>
<ul>
<li>HTTP/2 是二进制协议而不是文本协议。不再可读，也不可无障碍的手动创建，改善的优化技术现在可被实施。</li>
<li>这是一个复用协议。并行的请求能在同一个链接中处理，移除了 HTTP/1.x 中顺序和阻塞的约束。</li>
<li>压缩了 headers。因为 headers 在一系列请求中常常是相似的，其移除了重复和传输重复数据的成本。</li>
<li>其允许服务器在客户端缓存中填充数据，通过一个叫服务器推送的机制来提前请求。</li>
</ul>
<h2 id="https"><a href="#https" class="headerlink" title="https"></a>https</h2><p>是<code>HTTP</code>的安全版本，即有相应的<code>SSL</code>证书。</p>
<h2 id="常见的header"><a href="#常见的header" class="headerlink" title="常见的header"></a>常见的header</h2><h3 id="文件信息"><a href="#文件信息" class="headerlink" title="文件信息"></a>文件信息</h3><ul>
<li>Content-Tepy：<ul>
<li>text/plain；普通文本</li>
<li>tex/html：html文本</li>
<li>application/x-javascript：js</li>
<li>application/x-www-form-urlencoded：默认形式表单发包类型</li>
<li>multipart/form-data：用在发送文件的post包中</li>
<li>application/json：通过json传输</li>
<li>application/xml：通过xml传输</li>
</ul>
</li>
<li>Content-Length:用于指定请求或相应的内容长度<ul>
<li>如果存在Transfer-Encoding（chuncked）则在头信息中不能有Content-Type有也会被忽略</li>
<li>如果是短连接则可以通过关闭连接来确定长度</li>
<li>Content-Length必须与传输内容长度相同，过长会导致超时，过短会直接截断</li>
</ul>
</li>
</ul>
<h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><ul>
<li>Accept-Encoding</li>
<li>Content-Encoding</li>
</ul>
<h3 id="代理缓存"><a href="#代理缓存" class="headerlink" title="代理缓存"></a>代理缓存</h3><ul>
<li>Vary<ul>
<li>Accept</li>
<li>Accept-Encoding</li>
<li>Accept-Language</li>
<li>Accept-Charset</li>
</ul>
</li>
</ul>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><ul>
<li>Expires：过期时间</li>
<li>Cache-Control：缓存控制<ul>
<li>max-age:指示在多少秒之内，缓存方不用向服务器发送这个文件的请求，直接使用缓存。在max-age时间之内，浏览器请求该文件的响应总是为200(from cache)</li>
<li>no-cache：强制缓存方必须每次都向服务器发送请求，由服务器决定缓存方保存的是否为最新的文件。如果为最新的，服务器就会返回304(Not Modified)，缓存方直接使用缓存；如果不是最新返回200，并返回最新的文件。一般配合last-modified或Etag一起使用。</li>
<li>no-store：强制缓存方永远不缓存该文件，每次都是向服务器请求最新的文件</li>
<li>public：表示任何缓存方都可缓存该响应</li>
<li>private：只会缓存给该用户不会共享缓存</li>
</ul>
</li>
<li>Etag/If-None-Match<ul>
<li>缓存方第一次请求时，服务器返回的响应头中会包含一个Etag的hash</li>
<li>之后每次缓存方向服务器请求时都会包含一个If-None-Match头信息，内容为服务器返回的Etag，然后服务器对这个头信息进行判断，如果为最新的，服务器就会返回304(Not Modified)，缓存方直接使用缓存；如果不是最新返回200，并返回最新的文件，更新Etag字段。</li>
</ul>
</li>
<li>Last-Modified/If-Modified-Since：<ul>
<li>缓存方第一次请求时，服务器返回的响应头中会包含一个Last-Modified头信息，内容为该文件的最后更新时间</li>
<li>之后每次缓存方向服务器请求时都会包含一个If-Modified-Since头信息，内容为服务器返回的Last-Modified，然后服务器对这个头信息进行判断，如果为最新的，服务器就会返回304(Not Modified)，缓存方直接使用缓存；如果不是最新返回200，并返回最新的文件，更新Last-Modified字段。</li>
</ul>
</li>
</ul>
<h2 id="post实例"><a href="#post实例" class="headerlink" title="post实例"></a>post实例</h2><p>request：</p>
<pre><code>POST bilibili.com HTTP/1.1
accept:*/*
accept-encoding:gzip, deflate, br
accept-language: zh-CN,zh;q=0.9</code></pre><p>response:</p>
<pre><code>cache-control: max-age=0, no-cache, no-store, must-revalidate
content-language: zh-CN
content-length: 754
content-type: application/json
date:Fri, 29 Feb 2020 00:00:00 GMT
expires:Fri, 29 Feb 2020 00:00:00 GMT
status: 200
vary: Cookie</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/01/http%E5%B8%B8%E8%A7%81header/" data-id="ckbng8xpy0007dgug8xbje38h" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-http原理及请求组成" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/01/http%E5%8E%9F%E7%90%86%E5%8F%8A%E8%AF%B7%E6%B1%82%E7%BB%84%E6%88%90/" class="article-date">
  <time datetime="2020-03-01T07:35:09.852Z" itemprop="datePublished">2020-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/01/http%E5%8E%9F%E7%90%86%E5%8F%8A%E8%AF%B7%E6%B1%82%E7%BB%84%E6%88%90/">http原理及请求组成</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="http-原理及请求组成"><a href="#http-原理及请求组成" class="headerlink" title="http 原理及请求组成"></a>http 原理及请求组成</h1><h2 id="http-原理"><a href="#http-原理" class="headerlink" title="http 原理"></a>http 原理</h2><p>HTTP 协议工作于客户端-服务端架构上。浏览器作为 HTTP 客户端通过 URL 向 HTTP 服务端即 WEB 服务器发送所有请求。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>HTTP 是无连接的：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li>
<li>HTTP 是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过 HTTP 发送。客户端以及服务器指定使用适合的 MIME-type 内容类型。</li>
<li>HTTP 是无状态：HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li>
</ol>
<h2 id="请求组成"><a href="#请求组成" class="headerlink" title="请求组成"></a>请求组成</h2><h3 id="起始行"><a href="#起始行" class="headerlink" title="起始行"></a>起始行</h3><p>包含三个元素：</p>
<ul>
<li>一个 HTTP 方法：<code>GET</code> <code>PUT</code> <code>POST</code> <code>OPTION</code> <code>HEAD</code>等；</li>
<li>请求目标：通常是一个 URL，或者是协议、端口和域名的绝对路径；</li>
<li>HTTP 版本</li>
</ul>
<h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p>由不区分大小写的字符串，紧跟着的冒号 ‘:’ 和一个结构取决于 header 的值组成。 整个 header（包括值）由一行组成，这一行可以相当长。</p>
<ul>
<li>有许多请求header可用时，它们可以分为几组；</li>
</ul>
<h3 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h3><p>不是所有的请求都有一个 body：例如获取资源的请求，GET，HEAD，DELETE 和 OPTIONS，通常它们不需要 body。 有些请求将数据发送到服务器以便更新数据：常见的的情况是 POST 请求； 大致可以分为两类：</p>
<ul>
<li>Single-resource bodies：由一个单文件组成。该类型 body 由两个 header 定义： <code>Content-Type</code> 和 <code>Content-Length</code>.</li>
<li>Multiple-resource bodies：由多部分 body 组成，每一部分包含不同的信息位。通常是和 <code>HTML Forms</code> 连系在一起</li>
</ul>
<h2 id="响应组成"><a href="#响应组成" class="headerlink" title="响应组成"></a>响应组成</h2><h3 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h3><p>相应的起始行。包含：</p>
<ul>
<li>协议版本</li>
<li>状态码</li>
<li>状态文本</li>
</ul>
<p>例：<code>HTTP/1.1 404 Not Found</code></p>
<h3 id="Header-1"><a href="#Header-1" class="headerlink" title="Header"></a>Header</h3><p>与请求的 header 类似</p>
<h3 id="Body-1"><a href="#Body-1" class="headerlink" title="Body"></a>Body</h3><p>与请求的 body 类似，可分为三类：</p>
<ul>
<li>Multiple-resource bodies，由多部分 body 组成，每一部分包含不同的信息位。通常是和 HTML Forms 连系在一起</li>
<li>Single-resource bodies，由未知长度的单个文件组成，通过将 Transfer-Encoding 设置为 chunked 来使用 chunks 编码。</li>
<li>Multiple-resource bodies，由多部分 body 组成，每部分包含不同的信息段。但这是比较少见的。</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="浏览器这样的客户端发出的消息叫做-requests，被服务端响应的消息叫-responses"><a href="#浏览器这样的客户端发出的消息叫做-requests，被服务端响应的消息叫-responses" class="headerlink" title="浏览器这样的客户端发出的消息叫做 requests，被服务端响应的消息叫 responses"></a>浏览器这样的客户端发出的消息叫做 requests，被服务端响应的消息叫 responses</h3><h3 id="HTTP-Cookie"><a href="#HTTP-Cookie" class="headerlink" title="HTTP Cookie"></a>HTTP Cookie</h3><ul>
<li>HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。</li>
<li>主要用于会话状态管理、个性化设置、浏览器行为跟踪</li>
</ul>
<h3 id="一般的HTTP回话流程"><a href="#一般的HTTP回话流程" class="headerlink" title="一般的HTTP回话流程"></a>一般的HTTP回话流程</h3><ul>
<li>建立连接<ul>
<li>用户输入<code>URL</code>，客户端（浏览器）发起建立连接</li>
<li><code>URL</code>会包含域名和端口，当端口为80（默认）时，可以省略</li>
</ul>
</li>
<li>发送客户端请求<ul>
<li>建立连接后，用户代理（一般为浏览器）即可发送请求</li>
<li>请求分为三部分（<code>起始行</code> <code>header</code> <code>body</code>）</li>
</ul>
</li>
<li>服务器响应结构<ul>
<li>响应分为三部分（<code>起始行</code> <code>header</code> <code>body</code>）</li>
</ul>
</li>
</ul>
<h3 id="常见的响应状态码"><a href="#常见的响应状态码" class="headerlink" title="常见的响应状态码"></a>常见的响应状态码</h3><ul>
<li><code>200</code> ；OK 请求成功</li>
<li><code>301</code> ：Moved Permanently. 请求资源的 URI 已被改变</li>
<li><code>404</code> : Not Found. 服务器无法找到请求的资源</li>
<li><code>500</code> ：服务器内部错误</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/01/http%E5%8E%9F%E7%90%86%E5%8F%8A%E8%AF%B7%E6%B1%82%E7%BB%84%E6%88%90/" data-id="ckbng8xnd0006dgug8bng2hec" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/01/hello-world/" class="article-date">
  <time datetime="2020-02-29T19:06:30.594Z" itemprop="datePublished">2020-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/01/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/01/hello-world/" data-id="ckbng8xnd0005dgug46q7fbv6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/20/%E5%BD%93%E5%89%8D%E4%BB%BB%E5%8A%A1%E6%A2%B3%E7%90%86%EF%BC%886.20%EF%BC%89/">当前任务梳理（6.20）</a>
          </li>
        
          <li>
            <a href="/2020/05/21/React%E7%9A%84%E4%BC%98%E5%8A%BF/">React的优势</a>
          </li>
        
          <li>
            <a href="/2020/04/04/%E8%BD%AE%E6%92%AD%E5%9B%BE/">轮播图</a>
          </li>
        
          <li>
            <a href="/2020/04/02/da/">da</a>
          </li>
        
          <li>
            <a href="/2020/04/02/%E5%A4%A7%E6%95%B0%E7%9B%B8%E5%8A%A0/">大数相加</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Hamomo<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>