<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Hamomo">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-this是指向哪的" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/28/this%E6%98%AF%E6%8C%87%E5%90%91%E5%93%AA%E7%9A%84/" class="article-date">
  <time datetime="2020-03-28T08:44:15.825Z" itemprop="datePublished">2020-03-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/28/this%E6%98%AF%E6%8C%87%E5%90%91%E5%93%AA%E7%9A%84/">this是指向哪的</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h1><p>总的来说，指向离他最近的function关键字所属的对象。</p>
<p>一般绑定this的方法有以下几种：</p>
<ol>
<li>箭头函数</li>
<li>关键字new</li>
<li>显式绑定</li>
<li>隐式绑定</li>
<li>默认绑定</li>
</ol>
<p>以上按照优先级从高到低排列。</p>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><pre><code>function Person(){
  this.age = 0;
  setTimeout(function () {
    console.log(this.age);     // 输出undefined
  }, 1000);
}
var p = new Person();

function Person(){
  this.age = 10;
  setTimeout(()=&gt; {
    console.log(this.age);     // 输出10
  }, 1000);
}
var p = new Person();</code></pre><p>在上述的箭头函数的例子中，setTimeout内部的函数是被global调用的，而global没有阿哥这个属性，输出undefined。</p>
<p>第二个使用箭头函数，this会绑定在Person上；因为箭头函数不会绑定this，导致setTimeout函数内部的函数不会绑定到global上。</p>
<h2 id="new关键字"><a href="#new关键字" class="headerlink" title="new关键字"></a>new关键字</h2><pre><code>function foo() { 
    this.baz = &quot;baz&quot;; 
    console.log(this.bar + &quot; &quot; + baz); 
} 
    var baz = new foo();
var bar = &quot;bar&quot;; 
var baz = new foo(); </code></pre><p>new关键字在函数的调用前，会创建一个新的对象实例，这个函数为实例的构造函数。</p>
<p>按照前文提到的this绑定的方法，在这个例子中，离this最近的function是foo，此时foo属于baz，所以this指向的是baz对象，在baz上并没有bar，global上没有baz，所以输出undefined undefined。</p>
<h2 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h2><pre><code>function foo() { 
console.log(this.bar); 
} 
var bar = &quot;bar1&quot;; 
var obj = {bar: &quot;bar2&quot;}; 

foo();
foo.call(obj);</code></pre><p>通过call显示绑定this</p>
<h2 id="默认绑定和隐式绑定"><a href="#默认绑定和隐式绑定" class="headerlink" title="默认绑定和隐式绑定"></a>默认绑定和隐式绑定</h2><pre><code>function foo() { 
    console.log(this.bar); 
} 
var bar = &quot;bar1&quot;; 
var o2 = {bar: &quot;bar2&quot;, foo: foo}; 
var o3 = {bar: &quot;bar3&quot;, foo: foo}; 
foo();            // &quot;bar1&quot; – 默认绑定
o2.foo();          // &quot;bar2&quot; – 隐式绑定
o3.foo();          // &quot;bar3&quot; – 隐式绑定</code></pre><p>调用函数foo，foo的function所属的对象是window，所以foo的this.bar指window的bar。</p>
<p>在o2和o3中，foo的function所属的对象分别是o2和o3，所以，this.bar分别指bar2和bar3。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，this的指向除非通过一些方法显示规定，否则都是指向离他最近的function关键字所属的对象。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/28/this%E6%98%AF%E6%8C%87%E5%90%91%E5%93%AA%E7%9A%84/" data-id="ck8h4ln870000vwug37bb0aa6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-从输入URL到页面加载发生了什么" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/27/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/" class="article-date">
  <time datetime="2020-03-27T12:59:15.473Z" itemprop="datePublished">2020-03-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/27/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/">从输入URL到页面加载发生了什么</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="从输入-URL-到页面加载发生了什么"><a href="#从输入-URL-到页面加载发生了什么" class="headerlink" title="从输入 URL 到页面加载发生了什么"></a>从输入 URL 到页面加载发生了什么</h1><h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>首先，在回答在个问题之前，我们需要搞清楚<code>URL</code>是什么。</p>
<p>常见的 URL 会包含：</p>
<ul>
<li>协议名<br>常见的协议是 HTTP 协议，除此之外还包括<ul>
<li>HTTPS</li>
<li>FTP</li>
<li>FILE 等</li>
</ul>
</li>
<li>域名</li>
<li>端口号<br>端口号一般都是默认隐藏的，HTTP 协议默认端口是 80，HTTPS 协议默认端口是 443.</li>
<li>path<br>一般取决于服务器的路由结构</li>
<li>问号参数和 hash<ul>
<li>问号传参是客户端把信息传递给服务器的一种方式(也有可能是跳转到某一个页面，把参数值传递给页面用来标识的)</li>
<li>hash 主要用于页面中锚点定位和 hash 路由切换</li>
</ul>
</li>
</ul>
<h2 id="从输入-URL-到页面加载发生的事"><a href="#从输入-URL-到页面加载发生的事" class="headerlink" title="从输入 URL 到页面加载发生的事"></a>从输入 URL 到页面加载发生的事</h2><p>这个过程主要可以分为以下几个过程：</p>
<ul>
<li>DNS 解析</li>
<li>建立 TCP 连接</li>
<li>客户端发送 HTTP 协议</li>
<li>服务器返回 response</li>
<li>浏览器渲染页面</li>
<li>结束连接</li>
</ul>
<h3 id="DNS-解析"><a href="#DNS-解析" class="headerlink" title="DNS 解析"></a>DNS 解析</h3><p>DNS 解析是找到对应服务器的 IP 地址</p>
<ul>
<li>查找方法有：迭代和递归两种</li>
<li>查询的位置有<ul>
<li>浏览器缓存</li>
<li>操作系统缓存</li>
<li>本地域名服务器</li>
<li>顶级域名服务器</li>
<li>根域名服务器<br>直到获得准确的 IP 地址</li>
</ul>
</li>
</ul>
<h3 id="建立-TCP-连接"><a href="#建立-TCP-连接" class="headerlink" title="建立 TCP 连接"></a>建立 TCP 连接</h3><p>在获得 IP 地址后，便开始建立一次连接，由 TCP 协议完成，主要通过 3 次握手进行连接，作为前端工程师，这与我们的前端关系不大，就不细说。</p>
<h3 id="客户端发送-HTTP-请求"><a href="#客户端发送-HTTP-请求" class="headerlink" title="客户端发送 HTTP 请求"></a>客户端发送 HTTP 请求</h3><p>这里的客户端主要指浏览器，还有其他的，比如命令行和一些前端调试工具等。</p>
<h4 id="HTTP-与-HTTPS-的区别"><a href="#HTTP-与-HTTPS-的区别" class="headerlink" title="HTTP 与 HTTPS 的区别"></a>HTTP 与 HTTPS 的区别</h4><p>HTTP 报文是包裹在 TCP 报文中发送的，HTTP 报文是明文，容易被截取，所以就出现了 HTTPS。HTTPS 在讲 HTTP 报文包裹进 TCP 报文时，使用 SSL 进行了加密，HTTPS 在数据传输之前，客户端会与服务器进行一次握手，确定加密传输的密码信息，如此可以保证数据传输的安全性。</p>
<h4 id="HTTP-请求"><a href="#HTTP-请求" class="headerlink" title="HTTP 请求"></a>HTTP 请求</h4><p>包含三部分：请求行、请求报头和请求正文。</p>
<ul>
<li>请求行</li>
</ul>
<ol>
<li><p>一个 HTTP 方法：<code>GET</code> <code>PUT</code> <code>POST</code> <code>OPTION</code> <code>HEAD</code>等；</p>
</li>
<li><p>请求目标：通常是一个 URL，或者是协议、端口和域名的绝对路径；</p>
</li>
<li><p>HTTP 版本</p>
</li>
</ol>
<ul>
<li>header部分</li>
</ul>
<p>允许客户端向服务器传递请求的附加信息和客户端自身的信息，常见的请求报头有：</p>
<ol>
<li>Accept：指定客户端用于接受哪些类型的信息</li>
<li>Accept-Encoding：用于指定接受的编码方式</li>
<li>Connection：设置为Keep-alive用于告诉客户端本次HTTP请求结束之后并不需要关闭TCP连接，这样可以使下次HTTP请求使用相同的TCP通道，节省TCP连接建立的时间</li>
<li>Accept-Language：指定接受的语言</li>
<li>Cache-Control：缓存控制</li>
</ol>
<ul>
<li>请求正文</li>
</ul>
<p>当使用POST, PUT等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中。</p>
<h3 id="服务器返回-response"><a href="#服务器返回-response" class="headerlink" title="服务器返回 response"></a>服务器返回 response</h3><p>响应消息也是由三部分构成：状态行、响应消息报头以及响应正文</p>
<ul>
<li>状态行</li>
</ul>
<p>由HTTP协议版本号，状态码和原因描述组成</p>
<ol>
<li>状态码：常见的有200,304,404,500等</li>
</ol>
<ul>
<li>响应消息报头</li>
</ul>
<p>常见的报头有：</p>
<ol>
<li>Location：用于重定向接受者到一个新的位置</li>
<li>Server：包含了服务器用来处理请求的软件信息</li>
<li>Content-Length：用于指明实体正文的长度</li>
<li>Content-Type：用于指明发送给接收者的实体正文的媒体类型</li>
<li>其他等</li>
</ol>
<ul>
<li>响应正文</li>
</ul>
<p>一般是服务器发给客户端的内容，包括HTML、图片等</p>
<h3 id="浏览器渲染界面"><a href="#浏览器渲染界面" class="headerlink" title="浏览器渲染界面"></a>浏览器渲染界面</h3><p>如果说响应的内容是HTML文档的话，就需要浏览器进行解析渲染呈现给用户。整个过程涉及两个方面：解析和渲染；对于现代浏览器，为了达到更好的用户体验，浏览器的呈现引擎会力求尽快将内容显示到屏幕上；而不必等到整个HTML文档解析完毕之后再去构建渲染树然后布局渲染；也就是说这是一个渐进的过程。</p>
<h4 id="解析，构建对象模型"><a href="#解析，构建对象模型" class="headerlink" title="解析，构建对象模型"></a>解析，构建对象模型</h4><p>在渲染页面之前，需要构建DOM树和CSSOM树。</p>
<p>DOM树和CSSOM树的构建基本过程是这样的：</p>
<ol>
<li>Conversion转换：浏览器将获得的HTML内容（Bytes）基于他的编码转换为单个字符</li>
<li>Tokenizing分词：浏览器按照HTML规范标准将这些字符转换为不同的标记token。每个token都有自己独特的含义以及规则集</li>
<li>Lexing词法分析：分词的结果是得到一堆的token，此时把他们转换为对象，这些对象分别定义他们的属性和规则</li>
<li>DOM构建：因为HTML标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构一样</li>
</ol>
<h4 id="构建渲染树"><a href="#构建渲染树" class="headerlink" title="构建渲染树"></a>构建渲染树</h4><p>渲染树与DOM树对应，但并不是一一对应，因为非可视化的DOM元素不会被插入到渲染树中，例如head元素、display：none不会出现在渲染树。</p>
<h4 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h4><p>有了渲染树，就可以进行渲染了，包含四个步骤：</p>
<ol>
<li>计算CSS样式</li>
<li>构建渲染树</li>
<li>布局，主要定位坐标和大小，是否换行，各种position、overflow、z-index等</li>
<li>调用操作系统Native GUI的api绘制内容</li>
</ol>
<p>JS动态修改了DOM或者CSSOM，会导致重新布局或者渲染</p>
<p>这里涉及到了两个重要的概念：reflow（回流）和repaint（重绘）</p>
<ul>
<li>reflow：一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树，这个过程称为Reflow</li>
<li>repaint：意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就OK了，这个过程称为Repaint</li>
</ul>
<p>所以说Reflow的成本比Repaint的成本高得多的多。DOM树里的每个结点都会有reflow方法，一个结点的reflow很有可能导致子结点，甚至父点以及同级结点的reflow</p>
<p>下面这些动作很大可能会是成本比较高的：</p>
<ul>
<li>增加、删除、修改DOM结点时，会导致Reflow或Repaint</li>
<li>移动DOM的位置，或是搞个动画的时候</li>
<li>内容发生变化</li>
<li>修改CSS样式的时候</li>
<li>Resize窗口的时候（移动端没有这个问题），或是滚动的时候</li>
<li>修改网页的默认字体时</li>
</ul>
<p>注：display:none会触发reflow，而visibility:hidden只会触发repaint，因为没有发生位置变化。</p>
<p>基本上来说，reflow有如下的几个原因：</p>
<ul>
<li>网页初始化的时候</li>
<li>一些Javascript在操作DOM树时</li>
<li>其些元件的尺寸变了</li>
<li>如果CSS的属性发生变化了</li>
<li>几个Incremental的reflow发生在同一个frame的子树上</li>
</ul>
<h4 id="解析和渲染总结"><a href="#解析和渲染总结" class="headerlink" title="解析和渲染总结"></a>解析和渲染总结</h4><p>这里需要注意的一件事情就是在HTML解析过程中回去加载外链的CSS，但是不会影响继续解析HTML的；在外链CSS得到之后要解析CSS。从前面的介绍可知渲染的话是需要DOM和CSSOM一起构建出来渲染树，然后渲染出来的，也就是说默认情况下CSS是会阻塞渲染的，为啥说默认情况呢，难道还有不阻塞渲染的时候？答案是有的，通过media query就可以使得CSS资源是非阻塞渲染的。</p>
<h4 id="JS脚本"><a href="#JS脚本" class="headerlink" title="JS脚本"></a>JS脚本</h4><p>说完了DOM和CSSOM了，就该说说这个JS脚本了</p>
<p>通过JS脚本可以通过DOM API和CSSOM API来才做DOM树和CSSOM树（或者说CSS规则树）；但是呢JS是会阻塞DOM的构建（除非显示的声明为异步async的）也会阻塞CSSOM的构建，也就意味着会推迟这个页面的渲染完成。</p>
<p>在页面中的脚本有两种情况，一种就是内嵌的，还有一种外链的</p>
<p>对于脚本内嵌的情况，在解析HTML的过程中，直接执行脚本，这个时候会阻塞HTML解析来构建DOM，因为CSS不会修改DOM；还有一种情况那就是如果说正在脚本前面还有CSS的话，而此时CSSOM还未构建完成，那么浏览器就会推迟脚本的执行直至下载并构建好了CSSOM，而且在这个等待的过程中DOM的构建也会停止。所以说，在内嵌脚本之前不要有外链CSS，否则的话就会出现所谓的“CSS阻塞”，其实就是必须等到CSS加载完成解析构建CSSOM之后才会执行脚本，执行完脚本才会继续解析HTML构建DOM（这里Webkit则更智能一点，在执行脚本过程中发现引用了样式的话才暂停脚本的执行，等待CSS下载解析，然后再恢复）</p>
<p>然后第二种情况，对于外链脚本而言，在解析HTML的过程中发现了外链的脚本，会发一个请求去得到脚本内容，但是这个过程是同步的，需要等待脚本下载完成且执行之后才会继续解析HTML构建DOM；但是对于现代浏览器在这个时候会生成第二个线程解析HTML文档，会继续下载资源，所以有多个外链脚本的话，会并行请求下载脚本内容，但是浏览器对于一个域的资源是有最大并行限制的，一般是6个，超过的就只能等待了。脚本虽然可以并行加载，但是执行的顺序是按照在页面中先后顺序执行的，执行的过程会阻塞后续解析构建渲染，同样也会阻止其他资源的下载。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此，输入一个简单的URL到页面加载的简单过程就完毕了，在这个过程中，对于前端工程师而言，需要很熟悉页面的渲染过程，以消耗最少的成本完成页面的加载，代码的优化是无止境的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/27/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/" data-id="ck8h4ln8e0001vwug1l92537g" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-webpack中的loader和plugin" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/15/webpack%E4%B8%AD%E7%9A%84loader%E5%92%8Cplugin/" class="article-date">
  <time datetime="2020-03-15T00:40:33.485Z" itemprop="datePublished">2020-03-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/15/webpack%E4%B8%AD%E7%9A%84loader%E5%92%8Cplugin/">webpack中的loader和plugin</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h1><p>webpack 默认只识别 js 结尾的文件，当遇到其他格式后，webpack 并不知道如何去处理。此时，我们需要定义一种规则，告诉 webpack，当遇到其他类型的问件时，去求助于相应的 loader。</p>
<ul>
<li>识别出应该被对应的 loader 进行转换的文件。（test 属性）</li>
<li>转换这些文件，使其能够被添加到依赖图中。（use 属性）</li>
</ul>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><ul>
<li>test：匹配处理文件的拓展名的表达式，必须</li>
<li>user：使用的 loader 模块名称，必须</li>
<li>include/exclude：手动添加必须处理的文件（夹）或屏蔽不需要处理的文件，可选</li>
<li>query：为 loader 提供额外的设置选项，可选</li>
</ul>
<h1 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h1><p>loader 被用于转换某些类型的模块，而插件则可以用于执行广泛的任务。想要使用一个插件，你只需要 require()它，然后将它添加到 plugins 数组中。多数插件可以通过选项自定义。你也可以在一个配置中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建它的一个实例。</p>
<h2 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h2><pre><code>plugins:[执行的插件]</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/15/webpack%E4%B8%AD%E7%9A%84loader%E5%92%8Cplugin/" data-id="ck7se4upm0002esugh6wd32wn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-task" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/05/task/" class="article-date">
  <time datetime="2020-03-05T09:48:01.382Z" itemprop="datePublished">2020-03-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/05/task/">task</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Document</title>
  <style>
    .box{
      width: 1440px;
      margin: 0 auto;
      height: 5000px;
      background-color: aqua;
    }
  </style>
<meta name="generator" content="Hexo 4.2.0"></head>
<body>
  <div class="box">
    start
  </div>
  <div class="main">
    <div class="item"></div>
    <div class="item"></div>
    <div class="item"></div>
    <div class="item"></div>
    <div class="item"></div>
    <div class="item"></div>
  </div>
</body>
</html>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/05/task/" data-id="ck7se4upl0001esugal043lge" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-text" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/05/text/" class="article-date">
  <time datetime="2020-03-05T07:42:34.827Z" itemprop="datePublished">2020-03-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/05/text/">text</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Document</title>
<meta name="generator" content="Hexo 4.2.0"></head>
<body>
  <p>请输入半径</p>
  <input type="text" onchange="input()">
  <button>确认</button>
</body>
<script>
  function input(){
    const inputs=document.querySelector('input');
    const p=document.querySelector('p');
    p.textContent=inputs.value*inputs.value*3.14;
  }
</script>
</html>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/05/text/" data-id="ck7se4upd0000esug2zlzdrez" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-React异步" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/03/React%E5%BC%82%E6%AD%A5/" class="article-date">
  <time datetime="2020-03-02T16:45:30.081Z" itemprop="datePublished">2020-03-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/03/React%E5%BC%82%E6%AD%A5/">React异步</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="setState的异步调用"><a href="#setState的异步调用" class="headerlink" title="setState的异步调用"></a>setState的异步调用</h1><p><code>setState</code>是异步的，在class式的组件中，<code>this.state</code>表示当前渲染的值，在hook中<code>state</code>是同样的效果。</p>
<p>所以<code>this.setState</code>或者<code>setState</code>到底什么时候才会重新渲染呢？</p>
<p><code>setState</code> 函数用于更新 <code>state</code>。它接收一个新的 <code>state</code> 值并将组件的一次重新渲染加入队列。在后续的重新渲染中，useState 返回的第一个值将始终是更新后最新的 <code>state</code>。（这段话来自hook文档）</p>
<p>那么，“加入队列”怎么理解，“后续的重新渲染”又是什么时候呢？</p>
<p>先看一段代码：</p>
<pre><code>const [count, setCount] = React.useState(0);
return &lt;div&gt;
  &lt;p&gt;You clicked {count} times&lt;/p&gt;
  &lt;button onClick={() =&gt; setCount(count + 1)}&gt;click&lt;/button&gt;
  &lt;/div&gt;</code></pre><p>显而易见，打印的<code>count</code>的每次click都会加1，那么问题又来了，具体完成重新渲染是哪呢：是<code>onclick</code>函数执行完重新渲染呢，还是<code>setCount</code>执行完重新渲染呢？</p>
<p>观察下面的代码</p>
<pre><code>const [count, setCount] = React.useState(0);
function handleValue(){
  setCount(count+1)
  setCount(count+1)
}
return &lt;div&gt;
  &lt;p&gt;You clicked {count} times&lt;/p&gt;
  &lt;button onClick={handleValue}&gt;click&lt;/button&gt;
&lt;/div&gt;</code></pre><p>让我们猜一猜点击按钮一次，<code>count</code>的值是多少呢？</p>
<p>是1呢还是2呢？当然是1，所以setState并不会立刻rerender，正如上文所说，加入到了一个等待rerender的队列，按照上面的测试结果，我们是不是可以这样说：同一个函数内部的相同的setState只会执行一次，而它重新渲染是在其所在函数结束时。</p>
<p>真相真的是这样吗？</p>
<pre><code>const [count, setCount] = React.useState(0);
  function handleValue(){
    setCount((state)=&gt;state+1)
    setCount((state)=&gt;state+1)
  }
  return &lt;div&gt;
    &lt;p&gt;You clicked {count} times&lt;/p&gt;
    &lt;button onClick={handleValue}&gt;click&lt;/button&gt;
  &lt;/div&gt;</code></pre><p>那么这个点击一次的结果又是什么呢？</p>
<p>很明显这次不是1了，<code>count</code>是2了，这又是为什么呢？</p>
<p>首先要搞清参数<code>state</code>是什么</p>
<p>官方说法：<code>state</code> 是对应用变化时组件状态的引用。</p>
<p>通俗的说就是当前的<code>state</code>的值(<code>this.state</code>),也就是代码示例中的count值，因为count是不允许随意修改的，只能通过与其匹配的setCount传递值，所以这里使用了参数，所以这是一个很实惠(代码数量增加不多，解决的问题很关键)的消除异步的方法。(其实官方这样设计这个方法的时候目的是为了性能着想)</p>
<p>但是，关键的setState并不是总是异步的，只有在事件处理函数内部是才是异步的。</p>
<p>下面还有一段有趣的代码：</p>
<pre><code>const list=[1,1,1,1,1,1];
const [count, setCount] = React.useState([]);
function handleValue(){
  list.map((v:number)=&gt;{
    setCount([...count,v])
  })
}
return &lt;div&gt;
  &lt;p&gt; {count} &lt;/p&gt;
  &lt;button onClick={handleValue}&gt;click&lt;/button&gt;
&lt;/div&gt;</code></pre><p>setState的队列属性使得这种方法无法实现应有的效果，所以，我们修改：</p>
<pre><code>const list=[1,1,1,1,1,1];
const [count, setCount] = React.useState([]);
function handleValue(){
  list.map((v:number)=&gt;{
    setCount((state)=&gt;[...state,v])
  })
}
return &lt;div&gt;
  &lt;p&gt; {count} &lt;/p&gt;
  &lt;button onClick={handleValue}&gt;click&lt;/button&gt;
&lt;/div&gt;</code></pre><p>如此，这个问题便解决了</p>
<p>这个是之前项目中出现的问题，解决了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/03/React%E5%BC%82%E6%AD%A5/" data-id="ck7bwamyk0000cwugf4u20d3v" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-fetch相关api及异步" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/02/fetch%E7%9B%B8%E5%85%B3api%E5%8F%8A%E5%BC%82%E6%AD%A5/" class="article-date">
  <time datetime="2020-03-01T16:52:28.312Z" itemprop="datePublished">2020-03-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/02/fetch%E7%9B%B8%E5%85%B3api%E5%8F%8A%E5%BC%82%E6%AD%A5/">fetch相关api及异步</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="fetch-相关-API"><a href="#fetch-相关-API" class="headerlink" title="fetch 相关 API"></a>fetch 相关 API</h1><h2 id="fetch"><a href="#fetch" class="headerlink" title="fetch()"></a>fetch()</h2><p>fetch 请求</p>
<pre><code>fetch(&apos;http://example.com/movies.json&apos;)
.then(function(response) {
  return response.json();
})
.then(function(myJson) {
  console.log(myJson);
});</code></pre><p>他可以接受两个参数，可以为一个请求的基本信息，如下：</p>
<pre><code>function postData(url, data) {
  return fetch(url, {
    body: JSON.stringify(data), // must match &apos;Content-Type&apos; header
    cache: &apos;no-cache&apos;, // *default, no-cache, reload, force-cache, only-if-cached
    credentials: &apos;same-origin&apos;, // include, same-origin, *omit
    headers: {
      &apos;user-agent&apos;: &apos;Mozilla/4.0 MDN Example&apos;,
      &apos;content-type&apos;: &apos;application/json&apos;
    },
    method: &apos;POST&apos;, // *GET, POST, PUT, DELETE, etc.
    mode: &apos;cors&apos;, // no-cors, cors, *same-origin
    redirect: &apos;follow&apos;, // manual, *follow, error
    referrer: &apos;no-referrer&apos;, // *client, no-referrer
  })
  .then(response =&gt; response.json()) // parses response to JSON
}</code></pre><h2 id="上传-json-数据实例"><a href="#上传-json-数据实例" class="headerlink" title="上传 json 数据实例"></a>上传 json 数据实例</h2><pre><code>let url = &apos;https://example.com/profile&apos;;
let data = {username: &apos;example&apos;};

fetch(url, {
  method: &apos;POST&apos;, // or &apos;PUT&apos;
  body: JSON.stringify(data), // data can be `string` or {object}!
  headers: new Headers({
    &apos;Content-Type&apos;: &apos;application/json&apos;
  })
}).then(res =&gt; res.json())
.catch(error =&gt; console.error(&apos;Error:&apos;, error))
.then(response =&gt; console.log(&apos;Success:&apos;, response));</code></pre><h2 id="await"><a href="#await" class="headerlink" title="await"></a>await</h2><p>等待一个<code>promise</code>对象，只能在异步函数中使用。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre><code>[return_value] = await expression;</code></pre><p>expression：一个 Promise 对象或者任何要等待的值。<br>return_value：返回 Promise 对象的处理结果。如果等待的不是 Promise 对象，则返回该值本身。</p>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>await 表达式会暂停当前异步函数的执行，等待 Promise 处理完成。若 Promise 正常处理(fulfilled)，其回调的resolve函数参数作为 await 表达式的值，继续执行异步函数。</p>
<p>若 Promise 处理异常(rejected)，await 表达式会把 Promise 的异常原因抛出。</p>
<h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><p>看段代码：<br>    function read() {<br>      console.log(‘小明认真读书’);<br>    }</p>
<pre><code>function eat() {
  return new Promise((resolve, reject) =&gt; {
    console.log(&apos;好嘞，吃饭咯&apos;);
    setTimeout(() =&gt; {
      resolve(&apos;饭吃饱啦&apos;);
    }, 1000)
  })
}

const cooking = new Promise((resolve, reject) =&gt; {
  console.log(&apos;妈妈认真做饭&apos;);
  setTimeout(() =&gt; {
    resolve(&apos;小明快过来，开饭啦&apos;);
  }, 3000);
})

cooking.then(msg =&gt; {
  console.log(msg);
  return eat();
})
read();</code></pre><p>执行顺序：</p>
<p>妈妈认真做饭</p>
<p>小明认真读书</p>
<p>小明快过来，开饭了</p>
<p>好嘞，吃饭了</p>
<p>饭吃饱啦</p>
<p>promise的优点：将执行代码与处理数据的代码清晰的分离，在执行若干个异步函数时，将非常有用</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/02/fetch%E7%9B%B8%E5%85%B3api%E5%8F%8A%E5%BC%82%E6%AD%A5/" data-id="ck7bwamys0001cwug987jbnay" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-http常见header" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/01/http%E5%B8%B8%E8%A7%81header/" class="article-date">
  <time datetime="2020-03-01T07:35:09.863Z" itemprop="datePublished">2020-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/01/http%E5%B8%B8%E8%A7%81header/">http常见header</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="http-常见的-header"><a href="#http-常见的-header" class="headerlink" title="http 常见的 header"></a>http 常见的 header</h1><h2 id="get-和-post-的区别"><a href="#get-和-post-的区别" class="headerlink" title="get 和 post 的区别"></a>get 和 post 的区别</h2><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><ul>
<li><code>GET</code> 方法请求指定的资源。使用 GET 的请求应该只用于获取数据。</li>
</ul>
<h3 id="post"><a href="#post" class="headerlink" title="post"></a>post</h3><ul>
<li><code>POST</code> 方法发送数据给服务器. 请求主体的类型由 Content-Type 首部指定.<ul>
<li>一个 <code>POST</code> 请求通常是通过 HTML 表单发送, 并返回服务器的修改结果. 在这种情况下, content type 是通过在 <code>&lt;form&gt;</code> 元素中设置正确的 enctype 属性, 或是在 <code>&lt;input&gt;</code> 和 <code>&lt;button&gt;</code> 元素中设置 formenctype 属性来选择的;</li>
<li>当 POST 请求是通过除 HTML 表单之外的方式发送时, 例如使用 XMLHttpRequest, 那么请求主体可以是任何类型;</li>
</ul>
</li>
</ul>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li><code>get</code>只能获取数据，<code>post</code>可以发送数据，并返回服务器的修改结果</li>
</ul>
<h2 id="http2"><a href="#http2" class="headerlink" title="http2"></a>http2</h2><p>随着 web 应用的发展，更多的数据通过 HTTP 传输，HTTP/1.1 链接需要请求以正确的顺序发送，，带来的成本和复杂性堪忧。HTTP/2 应运而生。</p>
<p>HTTP/2 在 HTTP/1.1 有几处基本的不同:</p>
<ul>
<li>HTTP/2 是二进制协议而不是文本协议。不再可读，也不可无障碍的手动创建，改善的优化技术现在可被实施。</li>
<li>这是一个复用协议。并行的请求能在同一个链接中处理，移除了 HTTP/1.x 中顺序和阻塞的约束。</li>
<li>压缩了 headers。因为 headers 在一系列请求中常常是相似的，其移除了重复和传输重复数据的成本。</li>
<li>其允许服务器在客户端缓存中填充数据，通过一个叫服务器推送的机制来提前请求。</li>
</ul>
<h2 id="https"><a href="#https" class="headerlink" title="https"></a>https</h2><p>是<code>HTTP</code>的安全版本，即有相应的<code>SSL</code>证书。</p>
<h2 id="常见的header"><a href="#常见的header" class="headerlink" title="常见的header"></a>常见的header</h2><h3 id="文件信息"><a href="#文件信息" class="headerlink" title="文件信息"></a>文件信息</h3><ul>
<li>Content-Tepy：<ul>
<li>text/plain；普通文本</li>
<li>tex/html：html文本</li>
<li>application/x-javascript：js</li>
<li>application/x-www-form-urlencoded：默认形式表单发包类型</li>
<li>multipart/form-data：用在发送文件的post包中</li>
<li>application/json：通过json传输</li>
<li>application/xml：通过xml传输</li>
</ul>
</li>
<li>Content-Length:用于指定请求或相应的内容长度<ul>
<li>如果存在Transfer-Encoding（chuncked）则在头信息中不能有Content-Type有也会被忽略</li>
<li>如果是短连接则可以通过关闭连接来确定长度</li>
<li>Content-Length必须与传输内容长度相同，过长会导致超时，过短会直接截断</li>
</ul>
</li>
</ul>
<h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><ul>
<li>Accept-Encoding</li>
<li>Content-Encoding</li>
</ul>
<h3 id="代理缓存"><a href="#代理缓存" class="headerlink" title="代理缓存"></a>代理缓存</h3><ul>
<li>Vary<ul>
<li>Accept</li>
<li>Accept-Encoding</li>
<li>Accept-Language</li>
<li>Accept-Charset</li>
</ul>
</li>
</ul>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><ul>
<li>Expires：过期时间</li>
<li>Cache-Control：缓存控制<ul>
<li>max-age:指示在多少秒之内，缓存方不用向服务器发送这个文件的请求，直接使用缓存。在max-age时间之内，浏览器请求该文件的响应总是为200(from cache)</li>
<li>no-cache：强制缓存方必须每次都向服务器发送请求，由服务器决定缓存方保存的是否为最新的文件。如果为最新的，服务器就会返回304(Not Modified)，缓存方直接使用缓存；如果不是最新返回200，并返回最新的文件。一般配合last-modified或Etag一起使用。</li>
<li>no-store：强制缓存方永远不缓存该文件，每次都是向服务器请求最新的文件</li>
<li>public：表示任何缓存方都可缓存该响应</li>
<li>private：只会缓存给该用户不会共享缓存</li>
</ul>
</li>
<li>Etag/If-None-Match<ul>
<li>缓存方第一次请求时，服务器返回的响应头中会包含一个Etag的hash</li>
<li>之后每次缓存方向服务器请求时都会包含一个If-None-Match头信息，内容为服务器返回的Etag，然后服务器对这个头信息进行判断，如果为最新的，服务器就会返回304(Not Modified)，缓存方直接使用缓存；如果不是最新返回200，并返回最新的文件，更新Etag字段。</li>
</ul>
</li>
<li>Last-Modified/If-Modified-Since：<ul>
<li>缓存方第一次请求时，服务器返回的响应头中会包含一个Last-Modified头信息，内容为该文件的最后更新时间</li>
<li>之后每次缓存方向服务器请求时都会包含一个If-Modified-Since头信息，内容为服务器返回的Last-Modified，然后服务器对这个头信息进行判断，如果为最新的，服务器就会返回304(Not Modified)，缓存方直接使用缓存；如果不是最新返回200，并返回最新的文件，更新Last-Modified字段。</li>
</ul>
</li>
</ul>
<h2 id="post实例"><a href="#post实例" class="headerlink" title="post实例"></a>post实例</h2><p>request：</p>
<pre><code>POST bilibili.com HTTP/1.1
accept:*/*
accept-encoding:gzip, deflate, br
accept-language: zh-CN,zh;q=0.9</code></pre><p>response:</p>
<pre><code>cache-control: max-age=0, no-cache, no-store, must-revalidate
content-language: zh-CN
content-length: 754
content-type: application/json
date:Fri, 29 Feb 2020 00:00:00 GMT
expires:Fri, 29 Feb 2020 00:00:00 GMT
status: 200
vary: Cookie</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/01/http%E5%B8%B8%E8%A7%81header/" data-id="ck78qj0ve0001j8ug4cay2o7c" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-http原理及请求组成" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/01/http%E5%8E%9F%E7%90%86%E5%8F%8A%E8%AF%B7%E6%B1%82%E7%BB%84%E6%88%90/" class="article-date">
  <time datetime="2020-03-01T07:35:09.852Z" itemprop="datePublished">2020-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/01/http%E5%8E%9F%E7%90%86%E5%8F%8A%E8%AF%B7%E6%B1%82%E7%BB%84%E6%88%90/">http原理及请求组成</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="http-原理及请求组成"><a href="#http-原理及请求组成" class="headerlink" title="http 原理及请求组成"></a>http 原理及请求组成</h1><h2 id="http-原理"><a href="#http-原理" class="headerlink" title="http 原理"></a>http 原理</h2><p>HTTP 协议工作于客户端-服务端架构上。浏览器作为 HTTP 客户端通过 URL 向 HTTP 服务端即 WEB 服务器发送所有请求。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>HTTP 是无连接的：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li>
<li>HTTP 是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过 HTTP 发送。客户端以及服务器指定使用适合的 MIME-type 内容类型。</li>
<li>HTTP 是无状态：HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li>
</ol>
<h2 id="请求组成"><a href="#请求组成" class="headerlink" title="请求组成"></a>请求组成</h2><h3 id="起始行"><a href="#起始行" class="headerlink" title="起始行"></a>起始行</h3><p>包含三个元素：</p>
<ul>
<li>一个 HTTP 方法：<code>GET</code> <code>PUT</code> <code>POST</code> <code>OPTION</code> <code>HEAD</code>等；</li>
<li>请求目标：通常是一个 URL，或者是协议、端口和域名的绝对路径；</li>
<li>HTTP 版本</li>
</ul>
<h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p>由不区分大小写的字符串，紧跟着的冒号 ‘:’ 和一个结构取决于 header 的值组成。 整个 header（包括值）由一行组成，这一行可以相当长。</p>
<ul>
<li>有许多请求header可用时，它们可以分为几组；</li>
</ul>
<h3 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h3><p>不是所有的请求都有一个 body：例如获取资源的请求，GET，HEAD，DELETE 和 OPTIONS，通常它们不需要 body。 有些请求将数据发送到服务器以便更新数据：常见的的情况是 POST 请求； 大致可以分为两类：</p>
<ul>
<li>Single-resource bodies：由一个单文件组成。该类型 body 由两个 header 定义： <code>Content-Type</code> 和 <code>Content-Length</code>.</li>
<li>Multiple-resource bodies：由多部分 body 组成，每一部分包含不同的信息位。通常是和 <code>HTML Forms</code> 连系在一起</li>
</ul>
<h2 id="响应组成"><a href="#响应组成" class="headerlink" title="响应组成"></a>响应组成</h2><h3 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h3><p>相应的起始行。包含：</p>
<ul>
<li>协议版本</li>
<li>状态码</li>
<li>状态文本</li>
</ul>
<p>例：<code>HTTP/1.1 404 Not Found</code></p>
<h3 id="Header-1"><a href="#Header-1" class="headerlink" title="Header"></a>Header</h3><p>与请求的 header 类似</p>
<h3 id="Body-1"><a href="#Body-1" class="headerlink" title="Body"></a>Body</h3><p>与请求的 body 类似，可分为三类：</p>
<ul>
<li>Multiple-resource bodies，由多部分 body 组成，每一部分包含不同的信息位。通常是和 HTML Forms 连系在一起</li>
<li>Single-resource bodies，由未知长度的单个文件组成，通过将 Transfer-Encoding 设置为 chunked 来使用 chunks 编码。</li>
<li>Multiple-resource bodies，由多部分 body 组成，每部分包含不同的信息段。但这是比较少见的。</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="浏览器这样的客户端发出的消息叫做-requests，被服务端响应的消息叫-responses"><a href="#浏览器这样的客户端发出的消息叫做-requests，被服务端响应的消息叫-responses" class="headerlink" title="浏览器这样的客户端发出的消息叫做 requests，被服务端响应的消息叫 responses"></a>浏览器这样的客户端发出的消息叫做 requests，被服务端响应的消息叫 responses</h3><h3 id="HTTP-Cookie"><a href="#HTTP-Cookie" class="headerlink" title="HTTP Cookie"></a>HTTP Cookie</h3><ul>
<li>HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。</li>
<li>主要用于会话状态管理、个性化设置、浏览器行为跟踪</li>
</ul>
<h3 id="一般的HTTP回话流程"><a href="#一般的HTTP回话流程" class="headerlink" title="一般的HTTP回话流程"></a>一般的HTTP回话流程</h3><ul>
<li>建立连接<ul>
<li>用户输入<code>URL</code>，客户端（浏览器）发起建立连接</li>
<li><code>URL</code>会包含域名和端口，当端口为80（默认）时，可以省略</li>
</ul>
</li>
<li>发送客户端请求<ul>
<li>建立连接后，用户代理（一般为浏览器）即可发送请求</li>
<li>请求分为三部分（<code>起始行</code> <code>header</code> <code>body</code>）</li>
</ul>
</li>
<li>服务器响应结构<ul>
<li>响应分为三部分（<code>起始行</code> <code>header</code> <code>body</code>）</li>
</ul>
</li>
</ul>
<h3 id="常见的响应状态码"><a href="#常见的响应状态码" class="headerlink" title="常见的响应状态码"></a>常见的响应状态码</h3><ul>
<li><code>200</code> ；OK 请求成功</li>
<li><code>301</code> ：Moved Permanently. 请求资源的 URI 已被改变</li>
<li><code>404</code> : Not Found. 服务器无法找到请求的资源</li>
<li><code>500</code> ：服务器内部错误</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/01/http%E5%8E%9F%E7%90%86%E5%8F%8A%E8%AF%B7%E6%B1%82%E7%BB%84%E6%88%90/" data-id="ck78qj0v00000j8uggmso3gzb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/01/hello-world/" class="article-date">
  <time datetime="2020-02-29T19:06:30.594Z" itemprop="datePublished">2020-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/01/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/01/hello-world/" data-id="ck78km5x40000q8ug05d4do76" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/03/28/this%E6%98%AF%E6%8C%87%E5%90%91%E5%93%AA%E7%9A%84/">this是指向哪的</a>
          </li>
        
          <li>
            <a href="/2020/03/27/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/">从输入URL到页面加载发生了什么</a>
          </li>
        
          <li>
            <a href="/2020/03/15/webpack%E4%B8%AD%E7%9A%84loader%E5%92%8Cplugin/">webpack中的loader和plugin</a>
          </li>
        
          <li>
            <a href="/2020/03/05/task/">task</a>
          </li>
        
          <li>
            <a href="/2020/03/05/text/">text</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Hamomo<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>